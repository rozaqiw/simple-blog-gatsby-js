---
date: 2020-03-25
title: 'cpp'
template: post
thumbnail: '../thumbnails/js.png'
slug: cpp
categories:
  - Code
tags:
  - javascript
---

# C++面向对象高级开发

## C++编程简介

### class分类
	1.有指针的class
	2.无指针的class

### 基于对象与面向对象

基于对象：object based
    面对的是单一class的设计
面向对象：object oriented
    面对的是多重classes的设计，classes之间有关系

### 历史与演化

C++历史：new C -> C with class -> C++
C++演化：C++ 98(1.0) -> C++ 11(2.0)

### 图书推荐
语言：
    The C++ Programming Language
    C++ Primer
经验：
    Effective C++
标准库：
    STL源码剖析

## 头文件与类的声明

### C与C++对比
​    C语言有数据和函数。C语言没有对应的关键字，数据都是全局的。
​    C++语言将数据和对应的函数包装起来，变成class。C++的struct和class有一点不同。

### 以complex和string为例

complex(无指针的class)
    complex的数据有实部和虚部。函数有加减乘除等。
    数据可能有很多份，但函数只有一份。
    将真正的数据存储在对应的内存空间中。

``` 
    complex c2;
    complex* pc = new complex(0,1);
    complex c1(2,1);
```

string(有指针的class)
    string的数据其实就是一个指针，真正的数据存储在另外的内存空间中。函数有拷贝，删除等。

```    
    string s2("world");
    string* ps = new string;
    string s1("hello");
```

### C++代码头部

```cpp
#include <iostream.h> //引入标准库
#include "complex.h"  //引入自己写的Classes Declaration（声明）
```
扩展文件名不一定是.h或者.cpp
```cpp
C++中：#include <iostream.h> 等于 #include <iostream>
C中：#include<stdio.h> 等于 #include<cstdio>
```

### 防卫式声明

防卫式声明（guard），防止多次引用

```cpp
#ifndef __COMPLEX__
#define __COMPLEX__

----
0.前置声明
1.类声明
2.类定义
顺序：1->2->0
----

#endif 
```
### 类声明与模版

类的声明分成两个部分：class head, class body。

```cpp
//1.类声明
class complex   //class head
{               //class body
public:
complex (double r = 0, double i = 0): re(r), im(i){}
complex& operator += (const complex&); //只是声明，没有定义
double real() const { return re;}
double imag() const { return im;}

private:
double re, im;

friend complex& __doapl(complex*, const complex&);
}

{
    complex c1(2,1);
    complex c2;
}
```
使用类模版，使用时可以指定complex的实部与虚部的数据类型。
```cpp
template<typename T>
class complex   //class head
{               //class body
public:
complex (T r = 0, T i = 0): re(r), im(i){}
complex& operator += (const complex&);
T real() const { return re;}
T imag() const { return im;}

private:
T re, im;

friend complex& __doapl(complex*, const complex&);
}

{
    complex<double> c1(2.5, 1.4);  //使用者指定相应的类型
    complex<int> c2(2,6);
}
```
## 构造函数

### inline函数
inline函数定义在class body里，像宏macro一样，运行快
inline是对编译器的建议，是否变成inline函数由编译器决定

```cpp
complex (T r = 0, T i = 0): re(r), im(i){}
double real() const { return re; }	//inline函数
double imag() const { return im; }
```
如果不在class body内定义，需要加inline关键字，写在返回类型前面。
```cpp
inline double
imag(const complex& x)
{
    return x.imag();
}
```

### public与private的区别
private中主要是数据和仅供自己使用的函数，数据要通过函数传递出去。
public中主要是可以提供外界访问的函数。
public与private可以交错。

数据尽量放在private中。

```cpp
{
    complex c1(2,1);
    cout<<c1.re;     //错误
    cout<<c1.real(); //正确
}
```

### 构造函数

```cpp
complex c1(2,1);
complex c2;
complex* p = new complex(4);
```
以上三句均会调用构造函数，不能直接调用构造函数。
构造函数的名称一定与class的名称相同，没有返回类型。创建的对象就是complex。
```cpp
complex (T r = 0, T i = 0)  //r,i是实参，默认值为0.其他函数的实参也可以有默认值
: re(r), im(i)              //初始化列表initialzation list。其他函数没有这种语法
{ }
complex (T r = 0, T i = 0)
{ re = r, im = i }          //赋值assignments。与使用初始化列表的方式相比：变量初始化后，又多了赋值的过程。效率差。
```
不带指针的class，大部分无需写析构函数。

### 重载

同名函数可以有多个（重载overloading），编译后的名称不会相同。
```cpp
double real() const { return re; }  //编译后的名称可能是?real@Complex@@QBENXZ
double real(double r) { re = r; }   //?real@Complex@@QAENABN@Z
```
```cpp
complex (double r = 0, double i = 0): re(r), im(i){}    //已经有默认值的构造函数
complex (): re(0), im(0){}                              //与上一行冲突
```

## 参数传递与函数值
### 构造函数在private中的情况

```cpp
class A{        //singleton单体，一种设计模式
public:
    static A& getInstance();
    setup(){ ... }
private:
    A();				//将构造函数放在private中
    A(const A& rhs);
    ...
};

A& A::getInstance() //只能创建一份对象
{
    static A a; 
    return a;
}

A::getInstance().setup();
```
### const关键字
在不会改变private数据的函数的后面 + const

```cpp
double real() const { return re; } //只是将数据输出，并不改变数据
double imag() const { return im; }
```
如果不加const，以下就会出现错误
```cpp
double real()       { return re; }  //如果删除了const
double imag() const { return im; }

{
    const complex c1(2, 1);
    cout<<c1.real()<<endl;  //错误
    cout<<c1.imag()<<endl;  //正确
}
```
### 参数的传递

传值与传引用pass by value vs. pass by reference(to const)
传值时，会将整块数据传递过去，有时候需要传递的字节数很多。
传引用相当于传指针，速度快。
尽量选择传引用。

```cpp
complex& operator += (const complex&); //传递引用，但不希望传过去后被修改
```

### 返回值的传递
返回值与返回引用( return by value vs. return by reference(to const) )

尽量选择返回引用。

```cpp
complex& operator += (const complex&); 	//返回引用

double real() const { return re; } 		//返回值
double imag() const { return im; }
```

返回值与返回引用的情况：

​	1.运算结果存储在已存在的内存空间	-> 返回引用

```cpp
inline complex&
__doapl(complex* ths, const complex& r)	//do assignment plus.第一个参数会改变，第二个参数不会改变
{
    ths->re += r.re;
    ths->im += r.im;
    return *ths;	//结果存储在第一个参数中
}
inline complex&
complex::operator += (const complex& r)
{
    return __doapl(this, r);
}
```

​	2.运算结果存储在新建的内存空间	-> 返回值

​	因为本地变量会在函数结束时消失。

### 友元friend

```cpp
friend complex& __doapl(complex*, const complex&);

inline complex&
__doapl(complex* ths, const complex& r)
{
    ths->re += r.re;        //  friend可以直接取private中的数据
    ths->im += r.im;
    return *ths;
}
```
友元破坏了封装性。也可以不通过friend来实现。

### 相同class的各个对象互为友元

```cpp
class complex
{
public:
    complex(double r = 0, double i = 0) : re(r), im(i) { }
    
    int func(const complex& param)
    { return param.re + param.im; } //直接拿参数对象的数据
    
private: 
    double re, im;
};

{
    complex c1(2,1);
    complex c2;
    
    c2.func(c1); //c2对象通过func函数处理c1对象，func可以直接拿c1的私有数据   
}
```

## 操作符重载与临时对象

### 操作符重载，成员函数

this指调用者

传递者无需知道接收者是以引用形式接收

```cpp
//2-1类定义
inline complex&							//接收却是引用。传递者无需知道接收者是以引用形式接收
__doapl(complex* ths, const complex& r)	//ths是指针
{
    ths->re += r.re;
    ths->im += r.im;
    return *ths;						//返回ths指向的对象
}

inline complex& 
complex::operator += (const complex& r) //隐藏了this参数(this, const complex& r)
{
    return __doapl(this, r); 
}


c2 += c1; //调用时，c2作为this，c1作为r。c1是对象，接收者是引用。传递者无需知道接收者是以引用形式接收
c3 += (c2 += c1); //c1+c2的结果又加到c3上

```

### class body之外的类定义

```cpp
//2-2类定义
inline double
imag(const complex& x)
{
    return x.imag();
}
inline double
real(const complex& x)
{
    return x.real();
}

{
    complex c1(2,1);
    cout<<imag(c1);
    cout<<real(c1);
}
```

### 操作符重载，非成员函数

全局函数，没有this指针。

```cpp
//2-3
inline complex
operator + (const complex& x, const complex& y)
{
	return complex(real(x) + real(y), imag(x) + imag(y));//typename() ：创建临时对象
}
//c2 = c1 + c2
inline complex
operator + (const complex& x, double y)
{
    return complex(real(x) + y, imag(x));
}
//c2 = c1 + 5
inline complex
operator + (double x, const complex& y)
{
    return complex(x + real(y), imag(y));
}
//c2 = 7 + c1
```

以上三个函数不能返回引用，因为返回的是本地对象（返回的东西是在函数中创建出来的，离开这个函数后就消失了）。

typename() ：创建临时对象

```cpp
//2-4
inline complex
operator + (const complex& x)//可以返回引用，但此处是返回值
{
    return x;
}

inline complex
operator - (const complex& x)//不能返回引用
{
    return complex(-real(x), -imag(x));
}
//cout<<-c1;
//cout<<+c1;
```

```cpp
//2-5
inline bool
operator == (const complex& x, const complex& y)
{
    return real(x) == real(y) && imag (x) == imag (y) ;
}
//    cout << (c1 == c2);

inline bool
operator == (const complex& x, double y)
{
    return real (x) == y && imag (x) == 0;
}
//    cout << (c1 == 2);

inline bool
operator ==(double x, const complex& y)
{
  return x == real (y) && imag (y) == 0;
}
//    cout << (0 == c2);

```

```cpp
//2-6
inline bool
operator != (const complex& x, const complex& y)
{
    return real(x) != real(y) || imag(x) != imag(y);
}
//    cout << (c1 != c2);

inline bool
operator != (const complex& x, double y)
{
	return real(x) != y || imag(x) != 0;
}
//    cout << (c1 != 2);

inline bool
operator != (double x, const complex& y)
{
	return x != real(y) || imag(y) != 0;
}
//    cout << (0 != c2);

```

```cpp
//2-7
inline complex
conj (const complex& x)
{
    return complex(real(x), -imag(x));
}
---
#include <iostream.h>
using namespace std;
ostream&	//返回类型可以是void
operator << (ostream& os, const complex& x)//ostream&前没有加const，因为os在函数中改变了
{
    return os << '(' << real(x) << ',' << imag(x) << ')'; 
}
//cout << c1;

```

operator <<的返回类型可以是void，但不支持cout<<c1<<c2。

因为(cout<<c1)的结果仍需是cout才可以继续输出c2。

operator <<的返回类型不能为const stream&，因为(cout<<c1)完成后，后面还要接收c2。